<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>ArrayList详解 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="ArrayListArrayList 类位于 java.util 包中，使用前需要引入它 import java.util.ArrayList; &#x2F;&#x2F; 引入 ArrayList 类  1.创建ArrayListArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();  由于ArrayList实现了List接口，所以list变量类型可">
<meta property="og:type" content="article">
<meta property="og:title" content="ArrayList详解">
<meta property="og:url" content="http://example.com/2023/07/22/java_ArrayList/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="ArrayListArrayList 类位于 java.util 包中，使用前需要引入它 import java.util.ArrayList; &#x2F;&#x2F; 引入 ArrayList 类  1.创建ArrayListArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();  由于ArrayList实现了List接口，所以list变量类型可">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-07-22T06:08:14.000Z">
<meta property="article:modified_time" content="2025-08-26T08:45:46.618Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-java_ArrayList" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/22/java_ArrayList/" class="article-date">
  <time class="dt-published" datetime="2023-07-22T06:08:14.000Z" itemprop="datePublished">2023-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      ArrayList详解
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList 类位于 java.util 包中，使用前需要引入它</p>
<pre><code>import java.util.ArrayList; // 引入 ArrayList 类
</code></pre>
<h3 id="1-创建ArrayList"><a href="#1-创建ArrayList" class="headerlink" title="1.创建ArrayList"></a>1.创建ArrayList</h3><pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
</code></pre>
<p>由于ArrayList实现了List接口，所以list变量类型可以是List，&lt;&gt;中只能为引用数据类型。</p>
<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();
</code></pre>
<p>此时会调用无参构造方法构造一个空的数组，常量DEFAULTCAPACITY_EMPTY_ELEMENTDATA为{}，</p>
<pre><code>public ArrayList() &#123;
this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
&#125;
</code></pre>
<p>如果非常确定 ArrayList 中元素的个数，在创建的时候还可以指定初始大小。</p>
<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(20);
</code></pre>
<p>这样可以有效避免在添加新元素时进行不必要的扩容。</p>
<h3 id="2-向ArrayList中添加新元素"><a href="#2-向ArrayList中添加新元素" class="headerlink" title="2.向ArrayList中添加新元素"></a>2.向ArrayList中添加新元素</h3><p>可以通过add()方法向ArrayList中添加新元素。</p>
<pre><code>list.add(&quot;yexingyu&quot;);
</code></pre>
<p>添加新元素的过程如下：</p>
<pre><code>/**
* 将指定元素添加到 ArrayList 的末尾
* @param e 要添加的元素
* @return 添加成功返回 true
*/
public boolean add(E e) &#123;
    ensureCapacityInternal(size + 1);  // 确保 ArrayList 能够容纳新的元素
    elementData[size++] = e; // 在 ArrayList 的末尾添加指定元素
   return true;
&#125;
</code></pre>
<p>参数 e 为要添加的元素，此时的值为“yexingyu”，size 为 ArrayList 的长度，此时为 0。</p>
<pre><code>/**
* 确保 ArrayList 能够容纳指定容量的元素
* @param minCapacity 指定容量的最小值
*/
private void ensureCapacityInternal(int minCapacity) &#123;
  if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 如果 elementData   还是默认的空数组
       minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); // 使用   DEFAULT_CAPACITY 和指定容量的最小值中的较大值
   &#125;

    ensureExplicitCapacity(minCapacity); // 确保容量能够容纳指定容量的元素
&#125;
</code></pre>
<p>elementData 为存放 ArrayList 元素的底层数组，此时为空。<br>参数 minCapacity 为 1（size+1 传过来的）。<br>DEFAULTCAPACITY_EMPTY_ELEMENTDATA为0。<br>常数DEFAULT_CAPACITY 为 10。</p>
<pre><code>/**
 * 检查并确保集合容量足够，如果需要则增加集合容量。
*
* @param minCapacity 所需最小容量
*/
private void ensureExplicitCapacity(int minCapacity) &#123;
    // 检查是否超出了数组范围，确保不会溢出
    if (minCapacity - elementData.length &gt; 0)
        // 如果需要增加容量，则调用 grow 方法
        grow(minCapacity);
&#125;
</code></pre>
<p>参数 minCapacity 为 10<br>elementData.length 为 0（数组为空）</p>
<p>此时满足if条件执行grow方法。</p>
<pre><code>/**
 * 扩容 ArrayList 的方法，确保能够容纳指定容量的元素
 * @param minCapacity 指定容量的最小值
 */
private void grow(int minCapacity) &#123;
    // 检查是否会导致溢出，oldCapacity 为当前数组长度
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 扩容至原来的1.5倍
    if (newCapacity - minCapacity &lt; 0) // 如果还是小于指定容量的最小值
        newCapacity = minCapacity; // 直接扩容至指定容量的最小值
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 如果超出了数组的最大长度
        newCapacity = hugeCapacity(minCapacity); // 扩容至数组的最大长度
    // 将当前数组复制到一个新数组中，长度为 newCapacity
    elementData = Arrays.copyOf(elementData, newCapacity);
&#125;
</code></pre>
<p>可以发现现在ArrayList由0扩容到了10，每次扩容都会扩容到原来的1.5倍。根据扩容逻辑，当下次需要扩容时就是指定容量的最小值为11的时候，会把容量扩容到15，再下次就是指定容量的最小值为16时扩容到22了。</p>
<p>在检查完成后添加新元素  elementData[size++] &#x3D; e; &#x2F;&#x2F; 在 ArrayList 的末尾添加指定元素，就完成新增元素了。</p>
<h3 id="3-向ArrayList指定位置添加元素"><a href="#3-向ArrayList指定位置添加元素" class="headerlink" title="3.向ArrayList指定位置添加元素"></a>3.向ArrayList指定位置添加元素</h3><p>alist.add(0, “yexingyu”);</p>
<pre><code>public void add(int index, E element) &#123;
rangeCheckForAdd(index); // 检查索引是否越界

ensureCapacityInternal(size + 1);  // 确保容量足够，如果需要扩容就扩容
System.arraycopy(elementData, index, elementData, index + 1,
        size - index); // 将 index 及其后面的元素向后移动一位
elementData[index] = element; // 将元素插入到指定位置
size++; // 元素个数加一
&#125;
</code></pre>
<p>可以看到与添加新元素一样的扩容机制。添加的方法是将数组中index及之后的所有数据往后移动一位，然后将新数据插入index的位置。<br>System.arraycopy(elementData, index, elementData, index + 1, size - index);的解释：<br>elementData：表示要复制的源数组，即 ArrayList 中的元素数组。<br>index：表示源数组中要复制的起始位置，即需要将 index 及其后面的元素向后移动一位。<br>elementData：表示要复制到的目标数组，即 ArrayList 中的元素数组。<br>index + 1：表示目标数组中复制的起始位置，即将 index 及其后面的元素向后移动一位后，应该插入到的位置。<br>size - index：表示要复制的元素个数，即需要将 index 及其后面的元素向后移动一位，需要移动的元素个数为 size - index。</p>
<h3 id="4-更新ArrayList中的元素"><a href="#4-更新ArrayList中的元素" class="headerlink" title="4.更新ArrayList中的元素"></a>4.更新ArrayList中的元素</h3><p>list.set(0,”yexingyu”);</p>
<pre><code>/**
* 用指定元素替换指定位置的元素。
 *
* @param index   要替换的元素的索引
* @param element 要存储在指定位置的元素
* @return 先前在指定位置的元素
* @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常
*/
public E set(int index, E element) &#123;
    rangeCheck(index); // 检查索引是否越界

E oldValue = elementData(index); // 获取原来在指定位置上的元素
    elementData[index] = element; // 将新元素替换到指定位置上
    return oldValue; // 返回原来在指定位置上的元素
&#125;
</code></pre>
<p>可以看到一个检查是否越界的方法和更新元素的逻辑。查找索引对应位置的元素，返回并更新这个元素。</p>
<h3 id="5-删除ArrayList中的元素"><a href="#5-删除ArrayList中的元素" class="headerlink" title="5.删除ArrayList中的元素"></a>5.删除ArrayList中的元素</h3><pre><code>list.remove(1);
list.remove(&quot;yexingyu&quot;);
</code></pre>
<p>删除可以通过索引删除，也可以删除指定元素</p>
<pre><code>/**
* 删除指定位置的元素。
*
* @param index 要删除的元素的索引
* @return 先前在指定位置的元素
* @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常
*/
public E remove(int index) &#123;
    rangeCheck(index); // 检查索引是否越界

    E oldValue = elementData(index); // 获取要删除的元素

    int numMoved = size - index - 1; // 计算需要移动的元素个数
    if (numMoved &gt; 0) // 如果需要移动元素，就用 System.arraycopy 方法实现
        System.arraycopy(elementData, index+1, elementData, index,numMoved);
    elementData[--size] = null; // 将数组末尾的元素置为 null，让 GC 回收该元素占用的空间

    return oldValue; // 返回被删除的元素
&#125;
</code></pre>
<p>可以看到删除元素后需要其后所有的元素向前移动一位。然后将数组末尾的元素置为 null，以便让垃圾回收机制回收该元素占用的空间。</p>
<pre><code>/**
* 删除列表中第一次出现的指定元素（如果存在）。
*
* @param o 要删除的元素
* @return 如果列表包含指定元素，则返回 true；否则返回 false
*/
public boolean remove(Object o) &#123;
    if (o == null) &#123; // 如果要删除的元素是 null
        for (int index = 0; index &lt; size; index++) // 遍历列表
            if (elementData[index] == null) &#123; // 如果找到了 null 元素
                fastRemove(index); // 调用 fastRemove 方法快速删除元素
                return true; // 返回 true，表示成功删除元素
            &#125;
    &#125; else &#123; // 如果要删除的元素不是 null
        for (int index = 0; index &lt; size; index++) // 遍历列表
            if (o.equals(elementData[index])) &#123; // 如果找到了要删除的元素
                fastRemove(index); // 调用 fastRemove 方法快速删除元素
                return true; // 返回 true，表示成功删除元素
            &#125;
    &#125;
    return false; // 如果找不到要删除的元素，则返回 false
&#125;
</code></pre>
<p>该方法通过遍历的方式找到要删除的元素，null 的时候使用 &#x3D;&#x3D; 操作符判断，非 null 的时候使用 equals() 方法，然后调用 fastRemove() 方法删除元素。<br>需要注意只会删除查找到的第一个元素。</p>
<pre><code>/*
* @param index 要删除的元素的索引
*/
private void fastRemove(int index) &#123;
    int numMoved = size - index - 1; // 计算需要移动的元素个数
    if (numMoved &gt; 0) // 如果需要移动元素，就用 System.arraycopy 方法实现
        System.arraycopy(elementData, index+1, elementData, index,
                numMoved);
    elementData[--size] = null; // 将数组末尾的元素置为 null，让 GC 回收该元素占用的空间
&#125;
</code></pre>
<h3 id="6-查找ArrayList中的元素"><a href="#6-查找ArrayList中的元素" class="headerlink" title="6.查找ArrayList中的元素"></a>6.查找ArrayList中的元素</h3><p> 如果要正序查找一个元素，可以使用 indexOf() 方法；如果要倒序查找一个元素，可以使用 lastIndexOf() 方法。</p>
<pre><code>list.indexOf(&quot;yexingyu&quot;);
list.lastIndexOf(&quot;yexingyu&quot;);
</code></pre>
<p>源码：</p>
<pre><code>/**
* 返回指定元素在列表中第一次出现的位置。
* 如果列表不包含该元素，则返回 -1。
*
* @param o 要查找的元素
* @return 指定元素在列表中第一次出现的位置；如果列表不包含该元素，则返回 -1
*/
public int indexOf(Object o) &#123;
    if (o == null) &#123; // 如果要查找的元素是 null
        for (int i = 0; i &lt; size; i++) // 遍历列表
            if (elementData[i]==null) // 如果找到了 null 元素
                return i; // 返回元素的索引
    &#125; else &#123; // 如果要查找的元素不是 null
        for (int i = 0; i &lt; size; i++) // 遍历列表
            if (o.equals(elementData[i])) // 如果找到了要查找的元素
                return i; // 返回元素的索引
    &#125;
    return -1; // 如果找不到要查找的元素，则返回 -1
&#125;
</code></pre>
<p>如果元素为 null 的时候使用“&#x3D;&#x3D;”操作符，否则使用 equals() 方法。</p>
<pre><code>/**
* 返回指定元素在列表中最后一次出现的位置。
* 如果列表不包含该元素，则返回 -1。
*
* @param o 要查找的元素
* @return 指定元素在列表中最后一次出现的位置；如果列表不包含该元素，则返回 -1
*/
    public int lastIndexOf(Object o) &#123;
    if (o == null) &#123; // 如果要查找的元素是 null
        for (int i = size-1; i &gt;= 0; i--) // 从后往前遍历列表
            if (elementData[i]==null) // 如果找到了 null 元素
                return i; // 返回元素的索引
    &#125; else &#123; // 如果要查找的元素不是 null
        for (int i = size-1; i &gt;= 0; i--) // 从后往前遍历列表
            if (o.equals(elementData[i])) // 如果找到了要查找的元素
                return i; // 返回元素的索引
    &#125;
    return -1; // 如果找不到要查找的元素，则返回 -1
&#125;
</code></pre>
<p>与正序删除逻辑相同，不过遍历是从最后开始。<br>contains() 方法可以判断 ArrayList 中是否包含某个元素，其内部就是通过 indexOf() 方法实现的：</p>
<pre><code>public boolean contains(Object o) &#123;
    return indexOf(o) &gt;= 0;
&#125;
</code></pre>
<h3 id="7-二分查找"><a href="#7-二分查找" class="headerlink" title="7.二分查找"></a>7.二分查找</h3><p>如果 ArrayList 中的元素是经过排序的，就可以使用二分查找法，效率更快。</p>
<p>Collections 类的 sort() 方法可以对 ArrayList 进行排序，该方法会按照字母顺序对 String 类型的列表进行排序。如果是自定义类型的列表，还可以指定 Comparator 进行排序。</p>
<pre><code>List&lt;String&gt; copy = new ArrayList&lt;&gt;(alist);
copy.add(&quot;a&quot;);
copy.add(&quot;c&quot;);
copy.add(&quot;b&quot;);
copy.add(&quot;d&quot;);

Collections.sort(copy);
System.out.println(copy);

int index = Collections.binarySearch(copy, &quot;b&quot;);
</code></pre>
<h3 id="8-时间复杂度"><a href="#8-时间复杂度" class="headerlink" title="8.时间复杂度"></a>8.时间复杂度</h3><p>查询：时间复杂度为 O(1)，因为 ArrayList 内部使用数组来存储元素，所以可以直接根据索引来访问元素。</p>
<p>插入：添加一个元素（调用 add() 方法时）的时间复杂度最好情况为 O(1)，最坏情况为 O(n)。<br>如果在列表末尾添加元素，时间复杂度为 O(1)。<br>如果要在列表的中间或开头插入元素，则需要将插入位置之后的元素全部向后移动一位，时间复杂度为 O(n)。</p>
<p>删除：删除一个元素（调用 remove(Object) 方法时）的时间复杂度最好情况 O(1)，最坏情况 O(n)。<br>如果要删除列表末尾的元素，时间复杂度为 O(1)。<br>如果要删除列表中间或开头的元素，则需要将删除位置之后的元素全部向前移动一位，时间复杂度为 O(n)。</p>
<p>修改：修改一个元素（调用 set()方法时）与查询操作类似，可以直接根据索引来访问元素，时间复杂度为 O(1)。
    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/22/java_ArrayList/" data-id="cmesatsfv0000s4thhs0bbfg1" data-title="ArrayList详解" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/08/26/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/08/26/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2023/07/22/java_ArrayList/">ArrayList详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>